/**
 ******************************************************************************
 * @file    LwIP/LwIP_HTTP_Server_Netconn_RTOS/Src/main.c
 * @author  MCD Application Team
 * @brief   This sample code implements a http server application based on
 *          Netconn API of LwIP stack and FreeRTOS. This application uses
 *          STM32F7xx the ETH HAL API to transmit and receive data.
 *          The communication is done with a web browser of a remote PC.
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics International N.V.
 * All rights reserved.</center></h2>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted, provided that the following conditions are met:
 *
 * 1. Redistribution of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 3. Neither the name of STMicroelectronics nor the names of other
 *    contributors to this software may be used to endorse or promote products
 *    derived from this software without specific written permission.
 * 4. This software, including modifications and/or derivative works of this
 *    software, must execute solely and exclusively on microcontroller or
 *    microprocessor devices manufactured by or for STMicroelectronics.
 * 5. Redistribution and use of this software other than as permitted under
 *    this license is void and will automatically terminate your rights under
 *    this license.
 *
 * THIS SOFTWARE IS PROVIDED BY STMICROELECTRONICS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS, IMPLIED OR STATUTORY WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NON-INFRINGEMENT OF THIRD PARTY INTELLECTUAL PROPERTY
 * RIGHTS ARE DISCLAIMED TO THE FULLEST EXTENT PERMITTED BY LAW. IN NO EVENT
 * SHALL STMICROELECTRONICS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************
 */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "net_settings.h"
#include "cmsis_os.h"
#include "ethernetif.h"
#include "lwip/netif.h"
#include "lwip/tcpip.h"
#include "lwip/netbuf.h"
#include "lwip/ip_addr.h"
#include "app_ethernet.h"
#include "net_transport.h"
#include "rtc_utils.h"
#include "smarthome_log.h"
#include "ntp_client.h"
#include "google_iot.h"
#include "net_secure.h"

#ifdef __GNUC__
/* With GCC/RAISONANCE, small printf (option LD Linker->Libraries->Small printf
 set to 'Yes') calls __io_putchar() */
#define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
#else
#define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
#endif /* __GNUC__ */

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
#define DEFAULT_TIMEOUT 30000
/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
UART_HandleTypeDef uartHandle;
RNG_HandleTypeDef rngHandle;
NetTransportContext netTransportContext;
GGL_InitDef gglConfig;
NetSecure_InitTypeDef secConfig;

SemaphoreHandle_t printfMutex;

extern uint8_t DHCP_state;

/* Private function prototypes -----------------------------------------------*/
static void SystemClock_Config(void);
static void Peripherals_Config(void);
static void RNG_Init(void);
static void UART_Init(void);

static void SWStackThread_Start(void const * argument);
static void LCD_Config(void);
static void MPU_Config(void);
static void Error_Handler(void);
static void CPU_CACHE_Enable(void);

/* Private functions ---------------------------------------------------------*/

/**
 * @brief  Main program
 * @param  None
 * @retval None
 */
int main(void) {
	Peripherals_Config();

	printfMutex = xSemaphoreCreateMutex();

	/* Init thread */
	osThreadDef(Start, SWStackThread_Start, osPriorityNormal, 0, configMINIMAL_STACK_SIZE);
	osThreadCreate(osThread(Start), NULL);

	/* Start scheduler */
	osKernelStart();

	/* We should never get here as control is now taken by the scheduler */
	for (;;) {
	}
}

static void Wolfmqtt_PublishReceive(const char *host, int port) {
	int rc;
	if ((rc = GGL_MQTT_Connect()) != RC_SUCCESS) {
		printf("ERROR: GGL_MQTT_Connect FAILED %d - %s\r\n", rc,
				MqttClient_ReturnCodeToString(rc));
		return;
	}
	if ((rc = GGL_MQTT_Publish("events/report", "{\"state\": \"off\"}"))
			!= RC_SUCCESS) {
		printf("ERROR: GGL_MQTT_Publish FAILED %d - %s\r\n", rc,
				MqttClient_ReturnCodeToString(rc));
		return;
	}
	if ((rc = GGL_MQTT_Subscribe("config", MQTT_QOS_1)) != RC_SUCCESS) {
		printf("ERROR: GGL_MQTT_Subscribe FAILED %d - %s\r\n", rc,
				MqttClient_ReturnCodeToString(rc));
		return;
	}
	while (1) {
		if ((rc = GGL_MQTT_WaitForMessage(10000)) != RC_SUCCESS) {
			printf("ERROR: GGL_MQTT_WaitForMessage FAILED %d - %s\r\n", rc,
					MqttClient_ReturnCodeToString(rc));
		}
		if ((rc = GGL_MQTT_Ping()) != RC_SUCCESS) {
			printf("ERROR: GGL_MQTT_Ping FAILED %d - %s\r\n", rc,
					MqttClient_ReturnCodeToString(rc));
		}
	}

	GGL_MQTT_Disconnect();
}

void DHCPStateReportThread(void *argument) {
	while (DHCP_state != DHCP_ADDRESS_ASSIGNED ) {
		osDelay(1000);
	}
	NTPClient_Init("hu.pool.ntp.org", 123);
	uint32_t ntpTimestamp = 0;
	int rc = NTPClient_GetTimeSeconds(&ntpTimestamp);
	if (rc != 0) {
		printf("ERROR: Could not obtain NTP time\r\n");
		return;
	}
	RTCUtils_SetEpochTimestamp(ntpTimestamp);
	Wolfmqtt_PublishReceive("mqtt.googleapis.com", 8883);
	while (1) {
		/*uint32_t ntpTimestamp = 0;;
		 int rc = NTPClient_GetTimeSeconds(&ntpTimestamp);
		 if (rc != 0) {
		 printf("ERROR: could not read timestmap from NTP. rc=%d\r\n", rc);
		 }
		 else {
		 printf("NTP timestamp: %lu\r\n", ntpTimestamp);
		 }
		 osDelay(10000);*/
		/*
		 net_Connect(&netTransportContext, SOCKET_TCP,
		 "lwip-users.nongnu.narkive.com", 80, 2000);
		 net_Send(&netTransportContext,
		 "GET http://lwip-users.nongnu.narkive.com/ HTTP/1.1\r\n\r\n",
		 52, 2000);
		 char buf[512];
		 net_Receive(&netTransportContext, buf, 511, 2000);
		 net_Disconnect(&netTransportContext);
		 printf("Received: %s\r\n", buf);
		 osDelay(15000);*/
	}

}

// Test API Tread Ipm.
void API_TestThread(void *argument) {
	uint8_t ipAddress[4] = {192, 168, 178, 1};
	uint16_t port = 49000;
	char* request = "GET";// https://192.168.178.1:49000/getDeviceConfig HTTP/1.1\r\n";
	uint16_t requestLength = strlen(request);
	char responseBuffer[512];


	int rc = net_TLSConnectIp(&netTransportContext, SOCKET_TCP, ipAddress, port, DEFAULT_TIMEOUT);
	// ...error check, if rc != 0, then there was an error



	rc = net_TLSSend(&netTransportContext, request, requestLength, DEFAULT_TIMEOUT);
	// ...error check, if rc < 0 then there was an error


	rc = net_TLSReceive(&netTransportContext, responseBuffer, 511, DEFAULT_TIMEOUT);
	// ...error check, if rc < 0 then there was an error



}

int MQTT_HandleMessageCallback(const char* topic, const char* message) {
	printf("Message arrived in topic: %s\r\nMessage:%s\r\n", topic, message);
	return 0;
}

void vApplicationStackOverflowHook( TaskHandle_t xTask, signed char *pcTaskName ) {
	printf("######Â ERROR: Task %s ran into stack overflow! Check for memory leaks or increase the stack size of the corresponding thread!\r\n", pcTaskName);
}

/**
 * @brief  Start Thread
 * @param  argument not used
 * @retval None
 */
static void SWStackThread_Start(void const * argument) {
	/* Initialize LCD */
	LCD_Config();

	SHOME_DebugEnable();
	net_Init(&netTransportContext);

	secConfig.rngHandle = &rngHandle;
	secConfig.debugEnable = 1;
	net_SecureInit(&secConfig);
	RTCUtils_RTCInit();

	// initialize google stack
	GGL_DeviceDef device;
	device.deviceId = "test-iot-device-2";
	device.deviceRegistry = "greenfox-device-registry";
	device.projectId = "static-aventurin-fuchsit";
	device.region = "europe-west1";

	GGL_NetworkDef network;
	network.mqttHost = "mqtt.googleapis.com";
	network.mqttPort = 8883;

	gglConfig.callback = MQTT_HandleMessageCallback;
	gglConfig.device = device;
	gglConfig.network = network;
	GGL_IOT_Init(&gglConfig);

	//sys_thread_new("DHCP_REPORT", DHCPStateReportThread, NULL, 8192, osPriorityHigh);
	sys_thread_new("API_Test", API_TestThread, NULL, 8192, osPriorityHigh);

	for (;;) {
		/* Delete the Init Thread */
		osThreadTerminate(NULL);
	}
}

/**
 * @brief  Initializes the STM327546G-Discovery's LCD  resources.
 * @param  None
 * @retval None
 */
static void LCD_Config(void) {
	/* Initialize the LCD Layers */
	BSP_LCD_LayerDefaultInit(1, LCD_FB_START_ADDRESS);

	/* Set LCD Foreground Layer  */
	BSP_LCD_SelectLayer(1);

	BSP_LCD_SetFont(&LCD_DEFAULT_FONT);
}

static void Peripherals_Config(void) {
	/* Configure the MPU attributes as Device memory for ETH DMA descriptors */
	MPU_Config();

	/* Enable the CPU Cache */
	CPU_CACHE_Enable();

	/* STM32F7xx HAL library initialization:
	 - Configure the Flash ART accelerator on ITCM interface
	 - Configure the Systick to generate an interrupt each 1 msec
	 - Set NVIC Group Priority to 4
	 - Global MSP (MCU Support Package) initialization
	 */
	HAL_Init();

	/* Configure the system clock to 200 MHz */
	SystemClock_Config();

	/* init RNG */
	RNG_Init();

	/* init UART */
	UART_Init();

	/* Initialize the LCD */
	BSP_LCD_Init();
}

static void RNG_Init(void) {
	__HAL_RCC_RNG_CLK_ENABLE()
	;

	rngHandle.Instance = RNG;

	if (HAL_RNG_Init(&rngHandle) != HAL_OK) {
		printf("ERROR: could not configure RNG");
	}
}

static void UART_Init(void) {
	uartHandle.Init.BaudRate = 115200;
	uartHandle.Init.WordLength = UART_WORDLENGTH_8B;
	uartHandle.Init.StopBits = UART_STOPBITS_1;
	uartHandle.Init.Parity = UART_PARITY_NONE;
	uartHandle.Init.Mode = UART_MODE_TX_RX;

	BSP_COM_Init(COM1, &uartHandle);
}

/**
 * @brief  System Clock Configuration
 *         The system Clock is configured as follow :
 *            System Clock source            = PLL (HSE)
 *            SYSCLK(Hz)                     = 200000000
 *            HCLK(Hz)                       = 200000000
 *            AHB Prescaler                  = 1
 *            APB1 Prescaler                 = 4
 *            APB2 Prescaler                 = 2
 *            HSE Frequency(Hz)              = 25000000
 *            PLL_M                          = 25
 *            PLL_N                          = 432
 *            PLL_P                          = 2
 *            PLL_Q                          = 9
 *            VDD(V)                         = 3.3
 *            Main regulator output voltage  = Scale1 mode
 *            Flash Latency(WS)              = 7
 * @param  None
 * @retval None
 */
static void SystemClock_Config(void) {
	RCC_ClkInitTypeDef RCC_ClkInitStruct;
	RCC_OscInitTypeDef RCC_OscInitStruct;

	/* Enable HSE Oscillator and activate PLL with HSE as source */
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
	RCC_OscInitStruct.HSIState = RCC_HSI_OFF;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
	RCC_OscInitStruct.PLL.PLLM = 25;
	RCC_OscInitStruct.PLL.PLLN = 400;
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
	RCC_OscInitStruct.PLL.PLLQ = 9;
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
		Error_Handler();
	}

	/* activate the OverDrive */
	if (HAL_PWREx_EnableOverDrive() != HAL_OK) {
		Error_Handler();
	}

	/* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2
	 clocks dividers */
	RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK
			| RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK) {
		Error_Handler();
	}
}

/**
 * @brief  This function is executed in case of error occurrence.
 * @param  None
 * @retval None
 */
static void Error_Handler(void) {
	/* User may add here some code to deal with this error */
	while (1) {
	}
}

/**
 * @brief  Configure the MPU attributes as Device for  Ethernet Descriptors in the SRAM1.
 * @note   The Base Address is 0x20010000 since this memory interface is the AXI.
 *         The Configured Region Size is 256B (size of Rx and Tx ETH descriptors)
 *
 * @param  None
 * @retval None
 */
static void MPU_Config(void) {
	MPU_Region_InitTypeDef MPU_InitStruct;

	/* Disable the MPU */
	HAL_MPU_Disable();

	/* Configure the MPU attributes as Device for Ethernet Descriptors in the SRAM */
	MPU_InitStruct.Enable = MPU_REGION_ENABLE;
	MPU_InitStruct.BaseAddress = 0x20010000;
	MPU_InitStruct.Size = MPU_REGION_SIZE_256B;
	MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
	MPU_InitStruct.IsBufferable = MPU_ACCESS_BUFFERABLE;
	MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
	MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
	MPU_InitStruct.Number = MPU_REGION_NUMBER0;
	MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
	MPU_InitStruct.SubRegionDisable = 0x00;
	MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;

	HAL_MPU_ConfigRegion(&MPU_InitStruct);

	/* Enable the MPU */
	HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
}

/**
 * @brief  CPU L1-Cache enable.
 * @param  None
 * @retval None
 */
static void CPU_CACHE_Enable(void) {
	/* Enable I-Cache */
	SCB_EnableICache();

	/* Enable D-Cache */
	SCB_EnableDCache();
}

PUTCHAR_PROTOTYPE {
	/* Place your implementation of fputc here */
	/* e.g. write a character to the EVAL_COM1 and Loop until the end of transmission */
	HAL_UART_Transmit(&uartHandle, (uint8_t *) &ch, 1, 0xFFFF);

	return ch;
}

#ifdef  USE_FULL_ASSERT

/**
 * @brief  Reports the name of the source file and the source line number
 *         where the assert_param error has occurred.
 * @param  file: pointer to the source file name
 * @param  line: assert_param error line source number
 * @retval None
 */
void assert_failed(uint8_t* file, uint32_t line)
{
	/* User can add his own implementation to report the file name and line number,
	 ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */

	/* Infinite loop */
	while (1)
	{
	}
}
#endif

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
